## 垃圾回收

> 原因：创建一个变量需要内存空间，当变量不再被引用时，如果还继续占用内存空间的话，内存会吃不消，影响系统性能，所以必须要及时释放

### 垃圾回收策略

+ 标记清除

  首先会给所有变量都添加标记，在回收时，会从根对象向下遍历，如果可以访问到（`可达性`）就将它的标记去掉，带标记的变量就会被回收，之后再将所有变量加上标记

  缺点：***清除之后的变量，内存位置是不变的，导致内存空间不连续（内存碎片化），下次分配内存时，所花费的时间会增加（查找大于等于size的内存块，分配时间慢）***

  > 解决方案 — 标记整理
  >
  > 标记阶段和清除算法一样，但是在标记结束后，清除前，会将活着的对象向左对齐，清除掉所有左边对象

+ 引用计数

  当一个变量被其他变量引用时，或引用变量被引用时引用数加1，变量被取消引用时引用数减1。当引用数为0时，说明变量没有被引用，垃圾回收时会被回收

  缺点：***当循环引用时，两个变量都无法被回收，且计数器同样要占很大的内存***

### V8对垃圾回收的优化

+ 新老生代  — **V8会将内存分为`新生代区`和`老生代区`(略大)**
  + 新生代区又被分为使用区和空闲区，新加入的对象会被放到使用区，当使用区快满时，会对使用区的对象进行标记，复制到空闲区进行排序、清除，之后使用区和空闲区调换。
    + 当新生代多次未被清除，会被升到老生代
  + 老生代区采用标记整理方案
+ 新生代区 
  + 并行回收
    + 由于JS是单线程，导致垃圾回收时会阻塞脚本的运行(全停顿)，所以V8在采用多线程回收的方式
+ 老生代区
  + 增量标记 — 三色标记法
    + 即使并行回收可以增加效率，对于老生代的大对象而言极耗时间，所以将一次回收分为多次，逻辑和回收穿插进行
    + 采用白、灰、黑对对象进行标记。白：未被访问。灰：自身被访问，子对象未被访问。黑：自身和子对象皆被访问。起初所有对象都是白色，从根对象出发，由白—>灰—>黑转变，最后清除白色对象
      + 一旦有黑色引用白色，会默认将白色变为灰色
  + 惰性清理
    + 并不是每次都需要回收，当内存足以运行代码时，会执行代码，执行完毕再回收，使交互更流畅

**`在JS主线程执行时，辅助线程会进行并行标记，标记完再进行并行清理，清理采用增量的方式`**















